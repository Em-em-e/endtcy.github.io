// Generated by CoffeeScript 1.8.0
(function() {
  window.Tree = (function() {
    function Tree(size, max_depth, scene) {
      this.size = size;
      this.max_depth = max_depth;
      this.scene = scene;
      this.depth = this.size * 0.1;
      this.tree = void 0;
      this.object = new THREE.Object3D();
      this.rebuild(this.max_depth);
      this.scene.add(this.object);
    }

    Tree.prototype.rebuild = function(max_depth) {
      var delta, deltas, first_build, i, _fn, _i, _len;
      first_build = this.tree === void 0;
      if (max_depth === this.max_depth && !first_build) {
        return;
      }
      if (!first_build) {
        if (max_depth === 7) {
          deltas = [-1, 0, 1, 0, void 0, 1];
        } else {
          deltas = [-1];
        }
        _fn = function(delta, i) {
          if (delta === void 0) {
            return;
          }
          return setTimeout(function() {
            var howl;
            howl = new Howl({
              urls: ["sound/nan/sound" + (max_depth + 1 + delta) + "a.wav"],
              volume: Math.pow(max_depth / 10, 3)
            });
            return howl.play();
          }, i * 300);
        };
        for (i = _i = 0, _len = deltas.length; _i < _len; i = ++_i) {
          delta = deltas[i];
          _fn(delta, i);
        }
      }
      this.max_depth = max_depth;
      if (!first_build) {
        this.object.remove(this.tree);
      }
      this.tree = this.build(this.size, 0);
      return this.object.add(this.tree);
    };

    Tree.prototype.generate_box = function(size, color) {
      var box, geometry, material, mesh;
      geometry = new THREE.BoxGeometry(size * 0.1, size, this.depth);
      material = new THREE.MeshPhongMaterial({
        color: color,
        shininess: 0,
        ambient: color
      });
      mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      box = new THREE.Object3D;
      box.add(mesh);
      mesh.position.y = size / 2;
      return box;
    };

    Tree.prototype.build = function(size, depth) {
      var child, i, parent, ratio, _i;
      ratio = 1.0 * depth / this.max_depth / 2 + 0.5;
      parent = this.generate_box(size, new THREE.Color(0.5, 1.0 * ratio, 0.4 * ratio));
      if (depth + 1 < this.max_depth) {
        for (i = _i = 0; _i < 2; i = ++_i) {
          child = this.build(size / 1.6, depth + 1);
          parent.add(child);
          child.rotation.z = Math.PI * (-0.25 + i / 2);
          child.position.y = size;
        }
      }
      return parent;
    };

    return Tree;

  })();

}).call(this);

//# sourceMappingURL=tree.js.map
