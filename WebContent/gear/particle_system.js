// Generated by CoffeeScript 1.8.0
(function() {
  window.WeatherSystem = (function() {
    function WeatherSystem(scene) {
      var counter;
      this.scene = scene;
      this.rain_system = new RainSystem(scene);
      counter = 0;
      this.fog_system = new SpriteParticleSystem({
        intensity: 60,
        texture: 'images/smoke.png',
        depth: -1,
        generate_mesh: function() {
          var material, mesh, plane;
          plane = new THREE.PlaneBufferGeometry(10, 10);
          material = new THREE.MeshBasicMaterial({
            map: this.texture,
            blending: THREE.AdditiveBlending,
            depthTest: true,
            depthWrite: false
          });
          material.transparent = true;
          material.opacity = 0.0;
          mesh = new THREE.Mesh(plane, material);
          mesh.elapsed = 0;
          mesh.position.z = counter * 0.01;
          mesh.rotation.z = Math.random() * Math.PI * 2;
          counter += 1;
          counter %= this.intensity * 10;
          if (Math.random() >= 0.2) {
            mesh.speed = 0.1 + Math.random() * 0.2;
            mesh.position.x = (Math.random() - 0.5) * 60;
            mesh.position.y = (Math.random() - 0.5) * 40;
            mesh.sprite_size = Math.exp(Math.random());
            mesh.max_opacity = 0.03;
            mesh.velocity = 1;
          } else {
            mesh.speed = 0.1 + Math.random() * 0.2;
            mesh.speed /= 3.0;
            mesh.position.x = (Math.random() - 0.7) * 90;
            mesh.position.y = (Math.random() - 0.5) * 7 - 20;
            mesh.sprite_size = Math.exp(Math.random()) * 2;
            mesh.max_opacity = 0.03;
            mesh.velocity = 2;
          }
          return mesh;
        },
        update_mesh: function(mesh, t) {
          var s;
          mesh.elapsed += t * mesh.speed;
          if (this.is_dead(mesh)) {
            return false;
          }
          s = Math.max(Math.sqrt(mesh.elapsed), 0.001) * mesh.sprite_size;
          mesh.scale.set(s, s, s);
          mesh.position.x += t * mesh.velocity;
          mesh.material.opacity = (-Math.cos(mesh.elapsed * Math.PI * 2) / 2 + 0.5) * mesh.max_opacity;
          return true;
        },
        is_dead: function(mesh) {
          return mesh.elapsed > 1;
        }
      });
      scene.add(this.fog_system.object);
      this.star_system = new SpriteParticleSystem({
        intensity: 200,
        texture: 'images/square1x1.jpg',
        depth: -10,
        generate_mesh: function() {
          var material, mesh, plane, s;
          plane = new THREE.PlaneBufferGeometry(0.6, 0.6);
          material = new THREE.MeshBasicMaterial({
            map: this.texture,
            blending: THREE.AdditiveBlending,
            color: new THREE.Color(0.90, 1.0, 0.90)
          });
          material.opacity = 0;
          mesh = new THREE.Mesh(plane, material);
          mesh.elapsed = 0;
          mesh.speed = 0.03 + Math.random() * 0.3;
          mesh.position.x = (Math.random() - 0.5) * 120;
          mesh.position.y = (Math.random() - 0.5) * 20 + 35;
          mesh.position.z = counter * 0.01;
          mesh.rotation.z = Math.PI / 4;
          counter += 1;
          counter %= this.intensity * 10;
          mesh.sprite_size = Math.exp(Math.random()) * 0.2;
          s = 1e-7;
          mesh.scale.set(s, s, s);
          return mesh;
        },
        update_mesh: function(mesh, t) {
          var s;
          mesh.elapsed += t * mesh.speed;
          if (this.is_dead(mesh)) {
            return false;
          }
          s = 0.5 - Math.cos(mesh.elapsed * 2 * Math.PI) / 2;
          s *= mesh.sprite_size;
          mesh.scale.set(s, s, s);
          return true;
        },
        is_dead: function(mesh) {
          return mesh.elapsed > 1;
        }
      });
      scene.add(this.star_system.object);
    }

    WeatherSystem.prototype.set_intensity = function(weather, intensity) {
      return this[weather + '_system'].set_intensity(intensity);
    };

    WeatherSystem.prototype.update = function(t) {
      this.rain_system.update(t);
      this.fog_system.update(t);
      return this.star_system.update(t);
    };

    return WeatherSystem;

  })();

  window.RainSystem = (function() {
    RainSystem.prototype.update_particles = function(t) {
      var position, positions, _i, _len, _ref;
      positions = [];
      _ref = this.positions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        position = _ref[_i];
        position.x += 10 * t * this.velocity.x;
        position.y += 10 * t * this.velocity.y;
        position.z += 10 * t * this.velocity.z;
        if (position.y > -this.range) {
          positions.push(position);
        }
      }
      positions.sort(function() {
        return Math.random() - 0.5;
      });
      positions = positions.slice(0, this.particle_intensity);
      while (positions.length < this.particle_intensity) {
        positions.push({
          x: this.range * (2 * Math.random() - 1),
          y: this.range * (0.8 + Math.random() * 0.4),
          z: 0
        });
      }
      this.positions = positions;
      return this.update_geometry();
    };

    RainSystem.prototype.update_geometry = function() {
      var b, colors, dx, dy, dz, g, i, indices_array, positions, r, segments, x, y, z, _i, _j;
      segments = this.positions.length;
      positions = new Float32Array(segments * 6);
      colors = new Float32Array(segments * 8);
      dx = this.velocity.x;
      dy = this.velocity.y;
      dz = this.velocity.z;
      for (i = _i = 0; 0 <= segments ? _i < segments : _i > segments; i = 0 <= segments ? ++_i : --_i) {
        x = this.positions[i].x;
        y = this.positions[i].y;
        z = this.positions[i].z;
        positions[i * 6 + 0] = x;
        positions[i * 6 + 1] = y;
        positions[i * 6 + 2] = z;
        positions[i * 6 + 3] = x + dx;
        positions[i * 6 + 4] = y + dy;
        positions[i * 6 + 5] = z + dz;
        r = 1;
        g = 1;
        b = 0.5;
        colors[i * 8 + 0] = 0;
        colors[i * 8 + 1] = 0;
        colors[i * 8 + 2] = 0;
        colors[i * 8 + 3] = 0;
        colors[i * 8 + 4] = r / 4;
        colors[i * 8 + 5] = g / 4;
        colors[i * 8 + 6] = b / 4;
        colors[i * 8 + 7] = 1;
      }
      indices_array = [];
      for (i = _j = 0; 0 <= segments ? _j < segments : _j > segments; i = 0 <= segments ? ++_j : --_j) {
        indices_array.push(i, i + 1);
      }
      this.geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      this.geometry.addAttribute('color', new THREE.BufferAttribute(colors, 4));
      return this.geometry.computeBoundingSphere();
    };

    function RainSystem(scene) {
      var i, material, mesh, r, x, y, z, _i, _ref;
      this.scene = scene;
      this.howl = new Howl({
        urls: ["sound/rain.wav"],
        loop: true,
        volume: 0.01
      });
      this.howl.play();
      this.geometry = new THREE.BufferGeometry;
      material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        transparent: true,
        linewidth: 0.01,
        opacity: 0.9,
        blending: THREE.AdditiveBlending
      });
      this.positions = [];
      this.range = 60;
      r = this.range;
      this.set_intensity(0.0, true);
      for (i = _i = 0, _ref = this.particle_intensity; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        x = (Math.random() * 2 - 1) * r;
        y = (Math.random() * 2 - 1) * r;
        z = 0;
        this.positions.push({
          x: x,
          y: y,
          z: z
        });
      }
      this.velocity = new THREE.Vector3(-1, -7, 0);
      this.update_particles(0);
      mesh = new THREE.Line(this.geometry, material, THREE.LinePieces);
      mesh.rotation.y = Math.PI / 4;
      mesh.position.x = 20;
      mesh.position.z = 20;
      mesh.position.y = 25;
      scene.add(mesh);
    }

    RainSystem.prototype.set_current_intensity = function(intensity) {
      this.current_intensity = intensity;
      if (intensity < 0.01) {
        intensity = -1000;
      }
      this.particle_intensity = Math.floor(Math.exp(intensity * 9));
      return this.howl.volume(Math.exp(-(1 - intensity) * 8));
    };

    RainSystem.prototype.set_intensity = function(intensity, immediate) {
      this.intensity = intensity;
      if (immediate) {
        return this.set_current_intensity(this.intensity);
      }
    };

    RainSystem.prototype.update = function(t) {
      t /= 2;
      this.set_current_intensity(this.intensity - (this.intensity - this.current_intensity) * Math.exp(-t * 3));
      return this.update_particles(t);
    };

    return RainSystem;

  })();

  window.ParticleSystem = (function() {
    function ParticleSystem(options) {
      var p, pMaterial, particles, point_cloud, _i, _ref;
      this.texture = options.texture;
      this.generate_from = options.generate_from;
      this.update_particle = options.update_particle;
      this.is_dead = options.is_dead;
      this.intensity = options.intensity;
      this.elapsed = 0;
      particles = new THREE.Geometry;
      particles.dynamic = true;
      pMaterial = new THREE.PointCloudMaterial({
        color: 0x004422,
        size: 15,
        sizeAttenuation: false,
        map: THREE.ImageUtils.loadTexture(this.texture),
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthTest: false
      });
      for (p = _i = 0, _ref = this.intensity; 0 <= _ref ? _i < _ref : _i > _ref; p = 0 <= _ref ? ++_i : --_i) {
        particles.vertices.push(this.generate_particle());
      }
      this.particles = particles;
      point_cloud = new THREE.PointCloud(particles, pMaterial);
      this.object = point_cloud;
    }

    ParticleSystem.prototype.generate_particle = function() {
      var particle;
      particle = this.generate_from();
      return particle;
    };

    ParticleSystem.prototype.update = function(t) {
      var particle, particles, _i, _len, _ref;
      t *= 10;
      this.elapsed += t;
      particles = [];
      _ref = this.particles.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        this.update_particle(particle, t);
        if (!this.is_dead(particle)) {
          particles.push(particle);
        }
      }
      while (particles.length < this.intensity) {
        particles.push(this.generate_particle());
      }
      particles = particles.slice(0, this.intensity);
      this.particles.vertices = particles;
      return this.particles.verticesNeedUpdate = true;
    };

    return ParticleSystem;

  })();

  window.SpriteParticleSystem = (function() {
    function SpriteParticleSystem(options) {
      this.texture = THREE.ImageUtils.loadTexture(options.texture);
      this.generate_mesh = options.generate_mesh;
      this.update_mesh = options.update_mesh;
      this.is_dead = options.is_dead;
      this.intensity = options.intensity;
      this.depth = options.depth;
      if (this.depth === void 0) {
        this.depth = -1;
      }
      this.elapsed = 0;
      this.object = new THREE.Object3D();
      if (this.front) {
        this.object.position.x = 20;
        this.object.position.z = 20;
        this.object.position.y = 25;
      } else {
        this.object.position.x = -20;
        this.object.position.z = -20;
        this.object.position.y = -25;
      }
      this.object.rotation.y = Math.PI / 4;
    }

    SpriteParticleSystem.prototype.replace_mesh = function(old_mesh, new_mesh) {
      this.object.remove(old_mesh);
      return this.object.add(new_mesh);
    };

    SpriteParticleSystem.prototype.update = function(t) {
      var mesh, sprites, _i, _len, _results;
      this.elapsed += t;
      sprites = this.object.children.slice(0);
      for (_i = 0, _len = sprites.length; _i < _len; _i++) {
        mesh = sprites[_i];
        if (!this.update_mesh(mesh, t)) {
          this.object.remove(mesh);
        }
      }
      _results = [];
      while (this.object.children.length < this.intensity) {
        _results.push(this.object.add(this.generate_mesh()));
      }
      return _results;
    };

    return SpriteParticleSystem;

  })();

}).call(this);

//# sourceMappingURL=particle_system.js.map
