// Generated by CoffeeScript 1.8.0
(function() {
  var RGB, Slice, add_ground, binary_color, slice_counter, to_box2d_vectors, to_three_vectors;

  $.util = {};

  window.x = 1;

  $.util.binary_color = function(color) {
    var c;
    color = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = color.length; _i < _len; _i++) {
        c = color[_i];
        _results.push(Math.floor(c * 255));
      }
      return _results;
    })();
    return (color[0] << 16) + (color[1] << 8) + color[2];
  };

  $.util.RGB = function(color) {
    return [color[0] / 255.0, color[1] / 255.0, color[2] / 255.0];
  };

  $.util.to_three_vectors = function(vertices) {
    var vertex, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vertices.length; _i < _len; _i++) {
      vertex = vertices[_i];
      _results.push(new THREE.Vector2(vertex[0], vertex[1]));
    }
    return _results;
  };

  $.util.to_box2d_vectors = function(vertices) {
    var vertex, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vertices.length; _i < _len; _i++) {
      vertex = vertices[_i];
      _results.push(new Box2D.b2Vec2(vertex[0], vertex[1]));
    }
    return _results;
  };

  $.util.keyCode = {};

  to_three_vectors = $.util.to_three_vectors;

  to_box2d_vectors = $.util.to_box2d_vectors;

  binary_color = $.util.binary_color;

  RGB = $.util.RGB;

  $.WelcomeScene = (function() {
    function WelcomeScene(scene) {
      var geometry, i, j, material, _i, _j, _ref, _ref1;
      geometry = new THREE.BoxGeometry(1, 1, 1);
      material = new THREE.MeshBasicMaterial();
      this.w = 30;
      this.h = 30;
      this.phase = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (j = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(Math.random() * 2 * Math.PI);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      this.cube = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (j = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(new THREE.Mesh(geometry, material));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      for (i = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.cube[i][j].material = new THREE.MeshPhongMaterial();
          this.cube[i][j].position.x += i - this.w / 2;
          this.cube[i][j].position.z += j - this.h / 2;
          scene.add(this.cube[i][j]);
        }
      }
    }

    WelcomeScene.prototype.update = function(t) {
      var i, j, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.cube[i][j].position.y = Math.sin(this.phase[i][j] + t / 300) * 0.2 + 0.3);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return WelcomeScene;

  })();

  slice_counter = 0;

  $.Slice = (function() {
    function Slice(vertice_groups, scene, world, color, option) {
      var bd, body, box2d_vertices, depth, extrudeSettings, fixture_def, geometry, h, height, i, mask, material, mesh, shape, three_vertices, triangle, triangles, vertice_group, vertices, _i, _j, _k, _len, _len1, _ref, _ref1;
      this.vertice_groups = vertice_groups;
      this.scene = scene;
      this.world = world;
      this.color = color;
      this.id = slice_counter;
      slice_counter += 1;
      bd = new Box2D.b2BodyDef();
      bd.set_type(Box2D.b2_dynamicBody);
      bd.set_position(new Box2D.b2Vec2(0, 0));
      bd.set_linearDamping(0.3);
      bd.set_angularDamping(0.3);
      body = this.world.CreateBody(bd);
      this.meshes = [];
      for (_i = 0, _len = vertice_groups.length; _i < _len; _i++) {
        vertice_group = vertice_groups[_i];
        height = vertice_group.y;
        depth = vertice_group.depth || 1;
        vertices = vertice_group.vertices;
        color = this.color || ((function() {
          var _j, _results;
          _results = [];
          for (i = _j = 0; _j < 3; i = ++_j) {
            _results.push(i === (height + 10000) % 3 ? 1 : 0);
          }
          return _results;
        })());
        three_vertices = to_three_vectors(vertices);
        shape = new THREE.Shape(three_vertices);
        if (option) {
          extrudeSettings = {
            amount: depth,
            bevelEnabled: false,
            UVGenerator: option.uvGenerator
          };
        } else {
          extrudeSettings = {
            amount: depth,
            bevelEnabled: false
          };
        }
        geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        if (option) {
          material = new THREE.MeshLambertMaterial({
            map: option.map
          });
        } else {
          material = new THREE.MeshLambertMaterial({
            color: binary_color(color),
            ambient: binary_color(color)
          });
        }
        mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(0, 0, 0);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.rotateX(Math.PI / 2);
        scene.add(mesh);
        box2d_vertices = to_box2d_vectors(vertices);
        triangles = THREE.Shape.Utils.triangulateShape(three_vertices, []);
        for (_j = 0, _len1 = triangles.length; _j < _len1; _j++) {
          triangle = triangles[_j];
          shape = createPolygonShape([box2d_vertices[triangle[0]], box2d_vertices[triangle[1]], box2d_vertices[triangle[2]]]);
          fixture_def = new Box2D.b2FixtureDef();
          fixture_def.set_shape(shape);
          fixture_def.set_density(1);
          fixture_def.set_friction(0);
          mask = 0;
          for (h = _k = _ref = Math.floor(height), _ref1 = Math.ceil(height + depth); _ref <= _ref1 ? _k < _ref1 : _k > _ref1; h = _ref <= _ref1 ? ++_k : --_k) {
            mask += 1 << h;
          }
          fixture_def.get_filter().set_categoryBits(mask);
          fixture_def.get_filter().set_maskBits(mask);
          body.CreateFixture(fixture_def);
        }
        this.meshes.push({
          mesh: mesh,
          height: height
        });
      }
      this.body = body;
    }

    Slice.prototype.set_position = function(position) {
      var pos;
      pos = new Box2D.b2Vec2(position[0], position[1]);
      return this.body.SetTransform(pos, this.body.GetAngle());
    };

    Slice.prototype.set_angle = function(angle) {
      return this.body.SetTransform(this.body.GetPosition(), angle);
    };

    Slice.prototype.update = function() {
      var height, mesh, slice_mesh, _i, _len, _ref, _results;
      _ref = this.meshes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slice_mesh = _ref[_i];
        mesh = slice_mesh.mesh;
        height = slice_mesh.height;
        mesh.position.x = this.body.GetPosition().get_x();
        mesh.position.z = -this.body.GetPosition().get_y();
        mesh.position.y = height;
        mesh.rotation.set(0, 0, 0);
        mesh.rotation.y = this.body.GetAngle();
        mesh.rotateX(-Math.PI / 2);
        _results.push(mesh.needsUpdate = true);
      }
      return _results;
    };

    return Slice;

  })();

  window.get_wall_uvgen = function() {
    var uvgen;
    uvgen = {};
    uvgen.generateTopUV = function(geometry, indexA, indexB, indexC) {
      var a, b, c, m, max_x, max_y, min_x, min_y, ret, vec, vertices, _i, _len;
      vertices = geometry.vertices;
      max_x = -1e100;
      min_x = 1e100;
      max_y = -1e100;
      min_y = 1e100;
      for (_i = 0, _len = vertices.length; _i < _len; _i++) {
        vec = vertices[_i];
        max_x = Math.max(vec.x, max_x);
        min_x = Math.min(vec.x, min_x);
        max_y = Math.max(vec.y, max_y);
        min_y = Math.min(vec.y, min_y);
      }
      a = vertices[indexA];
      b = vertices[indexB];
      c = vertices[indexC];
      m = function(vec) {
        vec = new THREE.Vector2(vec.x, vec.y);
        vec.x = (vec.x - min_x) / (max_x - min_x);
        vec.y = (vec.y - min_y) / (max_y - min_y);
        return vec;
      };
      ret = [m(a), m(b), m(c)];
      return ret;
    };
    uvgen.generateSideWallUV = function(geometry, indexA, indexB, indexC, indexD) {
      var a, b, c, d, vertices;
      vertices = geometry.vertices;
      a = vertices[indexA];
      b = vertices[indexB];
      c = vertices[indexC];
      d = vertices[indexD];
      return [new THREE.Vector2(0, 0), new THREE.Vector2(0, 0), new THREE.Vector2(0, 0), new THREE.Vector2(0, 0)];
    };
    return uvgen;
  };

  add_ground = function(vertices, scene, world, slices, y) {
    var border, cross, delta, dx1, dx2, dy1, dy2, i, max_x, max_y, min_x, min_y, n, nx, ny, sgn, slice, texture, u, v, vec, w, _i, _j, _len;
    n = vertices.length;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      u = vertices[i];
      v = vertices[(i + 1) % n];
      w = vertices[(i + 2) % n];
      dx1 = w[0] - v[0];
      dy1 = w[1] - v[1];
      dx2 = v[0] - u[0];
      dy2 = v[1] - u[1];
      delta = 0;
      cross = dx1 * dy2 - dx2 * dy1;
      border = 1;
      if (cross > 0) {
        delta = 1;
      }
      if (cross < 0) {
        delta = -1;
      }
      sgn = function(x) {
        if (x === 0) {
          return 0;
        }
        if (x < 0) {
          return 1;
        }
        return -1;
      };
      nx = sgn(dx2);
      ny = sgn(dy2);
      v = [v[0] + border * nx * delta, v[1] + border * ny * delta];
      vec = [u, [u[0] - ny * border, u[1] + nx * border], [v[0] - ny * border, v[1] + nx * border], v];
      texture = THREE.ImageUtils.loadTexture('images/grass-green.jpg');
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(Math.abs(dx2), Math.abs(dy2));
      slice = new $.Slice([
        {
          vertices: vec,
          y: y,
          depth: 1.25
        }
      ], scene, world, [], {
        map: texture,
        uvGenerator: get_wall_uvgen()
      });
      slices.push(slice);
      slice.body.SetType(Box2D.b2_staticBody);
    }
    max_x = -1e100;
    min_x = 1e100;
    max_y = -1e100;
    min_y = 1e100;
    for (_j = 0, _len = vertices.length; _j < _len; _j++) {
      vec = vertices[_j];
      max_x = Math.max(vec[0], max_x);
      min_x = Math.min(vec[0], min_x);
      max_y = Math.max(vec[1], max_y);
      min_y = Math.min(vec[1], min_y);
    }
    texture = THREE.ImageUtils.loadTexture('images/restaurant.jpg');
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set((max_x - min_x) / 8, (max_y - min_y) / 8);
    slice = new $.Slice([
      {
        vertices: vertices,
        y: y,
        depth: 1
      }
    ], scene, world, [], {
      map: texture,
      uvGenerator: get_wall_uvgen()
    });
    slice.body.SetType(Box2D.b2_staticBody);
    slices.push(slice);
    return slice;
  };

  Slice = $.Slice;

  $.GameScene = (function() {
    function GameScene(scene) {
      var create_box, create_gear, create_polygon, gear, gravity, ground2, i, lavaBall, lavaMaterial, lavaTexture, player, tree, tree_ground_geometry, tree_ground_material, tree_ground_mesh, vertex, vertices, _i, _j, _k, _l, _len, _len1, _len2, _m;
      this.scene = scene;
      lavaTexture = THREE.ImageUtils.loadTexture('images/background.jpg');
      lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
      lavaTexture.repeat.set(1, 1);
      lavaMaterial = new THREE.MeshBasicMaterial({
        map: lavaTexture
      });
      lavaBall = new THREE.Mesh(new THREE.PlaneGeometry(96 * 1.2, 72 * 1.2, 0, 0), lavaMaterial);
      lavaBall.rotateY(Math.PI / 4);
      lavaBall.position.z = -40;
      lavaBall.position.x = -40;
      lavaBall.position.y = -47;
      scene.add(lavaBall);
      this.weather_system = new WeatherSystem(scene);
      this.particle_system = new ParticleSystem({
        texture: 'images/square.jpg',
        intensity: 50,
        generate_from: function() {
          var particle, x, y, z;
          x = (Math.random() - 0.5) * 10;
          y = Math.random() / 5;
          z = (Math.random() - 0.5) * 10;
          particle = new THREE.Vector3(x, y, z);
          particle.dy = Math.random() + 0.3;
          return particle;
        },
        update_particle: function(particle, t) {
          return particle.y += particle.dy * t * 0.3;
        },
        is_dead: function(particle) {
          return particle.y > 15;
        }
      });
      this.slices = [];
      this.joints = {};
      gravity = new Box2D.b2Vec2(0.0, 0.0);
      this.world = new Box2D.b2World(gravity);
      this.last_t = void 0;
      create_gear = function(r, d) {
        var D, angle, i, n, pol, result, _i;
        pol = function(t, a) {
          return [Math.cos(t) * a, Math.sin(t) * a];
        };
        n = Math.floor(r * Math.PI / d);
        D = d;
        result = [];
        angle = 2 * Math.PI / n;
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          result.push(pol(angle * i, r));
          result.push(pol(angle * i + angle * 0.4, r));
          result.push(pol(angle * i + angle * 0.6, r + D));
          result.push(pol(angle * i + angle * 0.8, r + D));
        }
        return result;
      };
      create_box = function(x, y, r) {
        return [[x - r, y - r], [x + r, y - r], [x + r, y + r], [x - r, y + r]];
      };
      create_polygon = function(x, y, r, n) {
        var i, pol, _i, _j, _results;
        pol = function(t, a) {
          return [Math.cos(t) * a, Math.sin(t) * a];
        };
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          [x + r * Math.cos(Math.PI * 2 / n * i), y + r * Math.sin(Math.PI * 2 / n * i)];
        }
        _results = [];
        for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
          _results.push([x + r * Math.cos(Math.PI * 2 / n * i), y + r * Math.sin(Math.PI * 2 / n * i)]);
        }
        return _results;
      };
      vertices = [
        {
          vertices: create_gear(1, 0.5),
          y: 0
        }
      ];
      for (i = _i = 0; _i < 10; i = ++_i) {
        vertices.push({
          vertices: create_polygon(0, 0, (10 - i) / 10, 8),
          y: 1 + 0.3 * i,
          depth: 0.3
        });
      }
      vertices.push({
        vertices: create_polygon(0, 0, 1, 4),
        y: 4,
        depth: 0.5
      });
      player = new Slice(vertices, scene, this.world, [1.0, 0.75, 0.72]);
      this.slices.push(player);
      player.body.SetBullet(true);
      player.set_position(-10, 0);
      vertices = [[30, -40], [30, -30], [40, -30], [40, 0], [0, 0], [0, 40], [-40, 40], [-40, -20], [-20, -20], [-20, -40]];
      for (_j = 0, _len = vertices.length; _j < _len; _j++) {
        vertex = vertices[_j];
        vertex[0] *= 0.5;
        vertex[1] *= 0.5;
      }
      this.ground = add_ground(vertices, scene, this.world, this.slices, -1);
      vertices = [[-20, -20], [0, -20], [0, 0], [-20, 0]];
      for (_k = 0, _len1 = vertices.length; _k < _len1; _k++) {
        vertex = vertices[_k];
        vertex[0] *= 0.4;
        vertex[1] *= 0.4;
      }
      ground2 = new Slice([
        {
          vertices: vertices,
          y: 3,
          depth: 1
        }
      ], scene, this.world, RGB([199, 240, 209]));
      this.slices.push(ground2);
      ground2.set_position(-20, 0);
      vertices = [[0, 0], [3, 0], [3, 2], [2, 2], [2, 1], [1, 1], [1, 2], [0, 2]];
      for (_l = 0, _len2 = vertices.length; _l < _len2; _l++) {
        vertex = vertices[_l];
        vertex[0] *= 3;
        vertex[1] *= 3;
      }
      gear = new Slice([
        {
          vertices: create_gear(4, 0.5),
          y: 0
        }, {
          vertices: create_gear(3, 0.5),
          y: 1
        }, {
          vertices: create_gear(2, 0.4),
          y: 2
        }
      ], scene, this.world, [1.0, 0.6, 0.8]);
      this.slices.push(gear);
      gear.set_position([5, -10]);
      gear.set_angle(0.01);
      this.pin_to_ground(gear);
      gear = new Slice([
        {
          vertices: create_gear(6, 0.5),
          y: 0,
          depth: 2
        }, {
          vertices: create_gear(4, 0.5),
          y: 2,
          depth: 1
        }, {
          vertices: create_gear(3, 0.5),
          y: 4,
          depth: 1
        }, {
          vertices: create_polygon(0, 0, 3, 5),
          y: 5,
          depth: 6
        }
      ], scene, this.world, [0.6, 0.95, 0.6]);
      this.slices.push(gear);
      gear.set_position([-10, 10]);
      gear.set_angle(0.04);
      this.gear2 = gear;
      this.pin_to_ground(gear);
      vertices = [
        {
          vertices: create_gear(3, 0.5),
          y: 1,
          depth: 0.5
        }, {
          vertices: create_polygon(0, 0, 3, 8),
          y: 1.5,
          depth: 0.5
        }, {
          vertices: create_polygon(0, 2.7, 0.2, 10),
          y: 2,
          depth: 5
        }, {
          vertices: create_polygon(0, -2.7, 0.2, 10),
          y: 2,
          depth: 5
        }, {
          vertices: create_polygon(-2.7, 0, 0.2, 10),
          y: 2,
          depth: 5
        }, {
          vertices: create_polygon(2.7, 0, 0.2, 10),
          y: 2,
          depth: 5
        }
      ];
      for (i = _m = 0; _m < 10; i = ++_m) {
        vertices.push({
          vertices: create_polygon(0, 0, (11 - i) / 10.0 * 3, 12 - i),
          y: 7 + 0.5 * i,
          depth: 0.5
        });
      }
      gear = new Slice(vertices, scene, this.world, [0.9, 0.7, 1.0]);
      this.slices.push(gear);
      gear.set_position([11.6, -10]);
      this.gear1 = gear;
      this.pin_to_ground(gear);
      tree = new Tree(7, 1, this.scene);
      this.tree = tree;
      tree_ground_geometry = new THREE.TableGeometry(10, 20, 10);
      tree_ground_material = new THREE.MeshLambertMaterial({
        color: 0xffaa66,
        shading: THREE.FlatShading,
        map: THREE.ImageUtils.loadTexture('images/table.png'),
        transparent: true
      });
      tree_ground_geometry.uvsNeedUpdate = true;
      tree_ground_mesh = new THREE.Mesh(tree_ground_geometry, tree_ground_material);
      this.tree_and_ground = new THREE.Object3D();
      this.tree_and_ground.add(tree.object);
      tree_ground_mesh.receiveShadow = true;
      tree_ground_mesh.position.y = -9.5;
      this.tree_and_ground.add(tree_ground_mesh);
      this.tree_and_ground.add(this.particle_system.object);
      this.scene.add(this.tree_and_ground);
    }

    GameScene.prototype.pin_to_ground = function(slice) {
      var jointDef;
      jointDef = new Box2D.b2RevoluteJointDef();
      jointDef.set_bodyA(slice.body);
      jointDef.set_bodyB(this.ground.body);
      jointDef.set_localAnchorA(new Box2D.b2Vec2(0.0, 0.0));
      jointDef.set_localAnchorB(slice.body.GetPosition());
      jointDef.set_collideConnected(false);
      return this.joints[slice.id] = Box2D.castObject(this.world.CreateJoint(jointDef), Box2D.b2WheelJoint);
    };

    GameScene.prototype.unpin = function(slice) {
      this.world.DestroyJoint(this.joints[slice.id]);
      return delete this.joints[slice.id];
    };

    GameScene.prototype.update = function(t, keyCode) {
      var intensity, mass_data, rotate, slice, speed, tree_angle, _i, _len, _ref;
      if (this.last_t === void 0) {
        this.last_t = t / 1000;
      }
      _ref = this.slices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slice = _ref[_i];
        slice.update();
      }
      t /= 1000;
      this.weather_system.update(t - this.last_t);
      this.particle_system.update(t - this.last_t);
      this.body = this.slices[0].body;
      speed = 2.9;
      slice = this.slices[0];
      rotate = keyCode['E'] || keyCode['Q'];
      this.scene.shadowLight.position.z = -800 * Math.cos(this.gear2.body.GetAngle());
      if (keyCode['A']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(-speed, -speed), this.body.GetPosition());
      }
      if (keyCode['D']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(speed, speed), this.body.GetPosition());
      }
      if (keyCode['W']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(-speed, speed), this.body.GetPosition());
      }
      if (keyCode['S']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(speed, -speed), this.body.GetPosition());
      }
      if (rotate) {
        this.body.SetLinearDamping(1.0);
        mass_data = new Box2D.b2MassData();
        this.body.GetMassData(mass_data);
        mass_data.set_mass(1e9);
        this.body.SetMassData(mass_data);
      } else {
        this.body.SetLinearDamping(0.3);
        this.body.ResetMassData();
      }
      if (rotate) {
        if (keyCode['E']) {
          this.body.ApplyAngularImpulse(speed * 1);
        }
        if (keyCode['Q']) {
          this.body.ApplyAngularImpulse(-speed * 1);
        }
      }
      this.world.Step(10 * (t - this.last_t), 8, 8);
      tree_angle = this.gear1.body.GetAngle() * 4;
      intensity = Math.abs((Math.floor(tree_angle / Math.PI + 6 + 0.25) % 12 + 12) % 12 - 6) + 1;
      this.weather_system.set_intensity('rain', intensity / 10);
      this.tree.rebuild(intensity);
      this.particle_system.intensity = 50;
      this.tree_and_ground.rotation.y = tree_angle;
      this.tree_and_ground.position.x = 15;
      this.tree_and_ground.position.z = -15;
      return this.last_t = t;
    };

    return GameScene;

  })();

  window.TestScene = (function() {
    function TestScene(scene) {
      var create_box, create_gear, create_polygon, gear, gravity, i, player, vertex, vertices, _i, _j, _len;
      this.scene = scene;
      this.slices = [];
      this.joints = {};
      gravity = new Box2D.b2Vec2(0.0, 0.0);
      this.world = new Box2D.b2World(gravity);
      this.last_t = void 0;
      create_gear = function(r, d) {
        var D, angle, i, n, pol, result, _i;
        pol = function(t, a) {
          return [Math.cos(t) * a, Math.sin(t) * a];
        };
        n = Math.floor(r * Math.PI / d);
        D = d;
        result = [];
        angle = 2 * Math.PI / n;
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          result.push(pol(angle * i, r));
          result.push(pol(angle * i + angle * 0.4, r));
          result.push(pol(angle * i + angle * 0.6, r + D));
          result.push(pol(angle * i + angle * 0.8, r + D));
        }
        return result;
      };
      create_box = function(x, y, r) {
        return [[x - r, y - r], [x + r, y - r], [x + r, y + r], [x - r, y + r]];
      };
      create_polygon = function(x, y, r, n) {
        var i, pol, _i, _j, _results;
        pol = function(t, a) {
          return [Math.cos(t) * a, Math.sin(t) * a];
        };
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          [x + r * Math.cos(Math.PI * 2 / n * i), y + r * Math.sin(Math.PI * 2 / n * i)];
        }
        _results = [];
        for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
          _results.push([x + r * Math.cos(Math.PI * 2 / n * i), y + r * Math.sin(Math.PI * 2 / n * i)]);
        }
        return _results;
      };
      vertices = [
        {
          vertices: create_gear(1, 0.5),
          y: 0
        }
      ];
      for (i = _i = 0; _i < 10; i = ++_i) {
        vertices.push({
          vertices: create_polygon(0, 0, (10 - i) / 10, 8),
          y: 1 + 0.3 * i,
          depth: 0.3
        });
      }
      vertices.push({
        vertices: create_polygon(0, 0, 1, 4),
        y: 4,
        depth: 0.5
      });
      player = new Slice(vertices, scene, this.world, [1.0, 0.75, 0.72]);
      this.slices.push(player);
      player.body.SetBullet(true);
      player.set_position(-10, 0);
      vertices = [[30, -40], [30, -30], [40, -30], [40, 0], [0, 0], [0, 40], [-40, 40], [-40, -20], [-20, -20], [-20, -40]];
      for (_j = 0, _len = vertices.length; _j < _len; _j++) {
        vertex = vertices[_j];
        vertex[0] *= 0.5;
        vertex[1] *= 0.5;
      }
      this.ground = add_ground(vertices, scene, this.world, this.slices, -1);
      gear = new Slice([
        {
          vertices: [[-0.6, -6], [0.6, -6], [0.6, 6], [-0.6, 6]],
          y: 0
        }
      ], scene, this.world, [1.0, 0.6, 0.8]);
      this.slices.push(gear);
      gear.set_position([5, -10]);
      gear.body.SetAngularDamping(0.5);
      this.block = gear;
      this.pin_to_ground(gear);
    }

    TestScene.prototype.pin_to_ground = function(slice) {
      var jointDef;
      jointDef = new Box2D.b2RevoluteJointDef();
      jointDef.set_bodyA(slice.body);
      jointDef.set_bodyB(this.ground.body);
      jointDef.set_localAnchorA(new Box2D.b2Vec2(0.0, 0.0));
      jointDef.set_localAnchorB(slice.body.GetPosition());
      jointDef.set_collideConnected(false);
      return this.joints[slice.id] = Box2D.castObject(this.world.CreateJoint(jointDef), Box2D.b2WheelJoint);
    };

    TestScene.prototype.unpin = function(slice) {
      this.world.DestroyJoint(this.joints[slice.id]);
      return delete this.joints[slice.id];
    };

    TestScene.prototype.update = function(t, keyCode) {
      var delta_angle, eps, mass_data, rotate, slice, speed, _i, _len, _ref;
      delta_angle = ((this.block.body.GetAngle() / Math.PI * 4 % 2.0) + 2) % 2 - 1;
      eps = 0.05;
      if (delta_angle > 0) {
        delta_angle = Math.max(0, delta_angle - eps);
      } else {
        delta_angle = Math.min(0, delta_angle + eps);
      }
      this.block.body.ApplyAngularImpulse(-delta_angle * 5);
      if (this.last_t === void 0) {
        this.last_t = t / 1000;
      }
      _ref = this.slices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slice = _ref[_i];
        slice.update();
      }
      t /= 1000;
      this.body = this.slices[0].body;
      speed = 2.9;
      slice = this.slices[0];
      rotate = keyCode['E'] || keyCode['Q'];
      if (keyCode['A']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(-speed, -speed), this.body.GetPosition());
      }
      if (keyCode['D']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(speed, speed), this.body.GetPosition());
      }
      if (keyCode['W']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(-speed, speed), this.body.GetPosition());
      }
      if (keyCode['S']) {
        this.body.ApplyLinearImpulse(new Box2D.b2Vec2(speed, -speed), this.body.GetPosition());
      }
      if (rotate) {
        this.body.SetLinearDamping(1.0);
        mass_data = new Box2D.b2MassData();
        this.body.GetMassData(mass_data);
        mass_data.set_mass(1e9);
        this.body.SetMassData(mass_data);
      } else {
        this.body.SetLinearDamping(0.3);
        this.body.ResetMassData();
      }
      if (rotate) {
        if (keyCode['E']) {
          this.body.ApplyAngularImpulse(speed * 9);
        }
        if (keyCode['Q']) {
          this.body.ApplyAngularImpulse(-speed * 9);
        }
      }
      this.world.Step(10 * (t - this.last_t), 8, 8);
      return this.last_t = t;
    };

    return TestScene;

  })();

}).call(this);

//# sourceMappingURL=scenes.js.map
